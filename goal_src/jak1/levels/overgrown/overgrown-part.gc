(deftype overgrown-part (part-spawner) ())


(defpartgroup group-overgrown-waterfall-1
  :id 153
  :flags (always-draw)
  :bounds (static-bspherem 0 16 0 32)
  :parts
  ((sp-item 782 :fade-after (meters 160) :falloff-to (meters 160))
   ;;(sp-item 783 :fade-after (meters 160) :falloff-to (meters 160))
   ;;(sp-item 784 :fade-after (meters 160) :falloff-to (meters 160))
   ;;(sp-item 785 :fade-after (meters 80) :falloff-to (meters 80))
   ;;(sp-item 786 :fade-after (meters 160) :falloff-to (meters 160))
   ;;(sp-item 787 :fade-after (meters 160) :falloff-to (meters 160))
   ))

(defpart 789
  :init-specs ((:fade-a -0.10666667)))

(defpart 790
  :init-specs ((:fade-a -0.16)))

(defpart 791
  :init-specs ((:fade-a -2.6666667)))

(defpart 782
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 0.9)
   (:x (meters -9) (meters 1))
   (:y (meters 47))
   (:z (meters -1) (meters 2))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0.05))
   (:vel-y (meters 0.013333334) (meters 0.013333334))
   (:vel-z (meters -0.0016666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-x (meters -0.00091074686))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 1.28))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:next-launcher 791)
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees 180))))

(defpart 783
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 0.9)
   (:x (meters -9) (meters 1))
   (:y (meters 39) (meters 5))
   (:z (meters 0))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0.05) (meters 0.013333334))
   (:vel-y (meters 0.013333334) (meters 0.013333334))
   (:vel-z (meters 0.011666667) (meters 0.01))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-x (meters -0.00091074686))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 0.7))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:next-launcher 791)
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees 90))))

(defpart 784
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 1.0)
   (:x (meters -2) (meters 3))
   (:y (meters 24) (meters 6))
   (:z (meters 2))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 4.8) (meters 3.2))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0) (meters 0.026666667))
   (:vel-y (meters -0.01) (meters 0.0033333334))
   (:vel-z (meters -0.021666666) (meters 0.013333334))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 0.9))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:next-launcher 791)
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees 90))))

(defpart 785
  :init-specs
  ((:texture (new 'static 'texture-id :index #x4 :page #x2))
   (:num 1.0)
   (:x (meters -9) (meters 1))
   (:y (meters 47))
   (:z (meters -1) (meters 2))
   (:scale-x (meters 0.2) (meters 0.2))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 24.0)
   (:vel-x (meters 0.05) (meters 0.013333334))
   (:vel-y (meters 0.0033333334) (meters 0.02))
   (:vel-z (meters -0.006666667) (meters 0.013333334))
   (:scalevel-x (meters -0.00024414062))
   (:scalevel-y (meters 0.001953125))
   (:accel-x (meters -0.00069444446))
   (:accel-y (meters -0.0016666667) (meters -0.00083333335))
   (:timer (seconds 1.7))
   (:flags (bit2 bit3))
   (:launchrot-x (degrees -20) (degrees 40))
   (:rotate-y (degrees 90))))

(defpart 786
  :init-specs
  ((:texture (new 'static 'texture-id :page #x2))
   (:num 0.5 0.4)
   (:x (meters -7) (meters 3.5))
   (:y (meters 47))
   (:z (meters -1) (meters 2))
   (:scale-x (meters 1.2) (meters 0.8))
   (:rot-z (degrees 0) (degrees 180))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 16.0 16.0)
   (:vel-x (meters 0.021666666))
   (:vel-y (meters -0.0033333334) (meters 0.01))
   (:vel-z (meters -0.0033333334) (meters 0.006666667))
   (:scalevel-x (meters 0.0146484375))
   (:rotvel-z (degrees -0.6) (degrees 1.2))
   (:scalevel-y (meters 0.0146484375))
   (:accel-x (meters -0.00029040404))
   (:accel-y (meters -0.001) (meters -0.00025))
   (:timer (seconds 2.27))
   (:flags (bit2))
   (:next-time (seconds 2.22))
   (:next-launcher 791)
   (:rotate-y (degrees 90))))

(defpart 787
  :init-specs
  ((:texture (new 'static 'texture-id :index #x19 :page #x2))
   (:num 0.133)
   (:x (meters 0) (meters 6))
   (:y (meters -3.5))
   (:z (meters -5) (meters 10))
   (:scale-x (meters 12))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0)
   (:vel-x (meters -0.006666667) (meters 0.02))
   (:vel-y (meters 0.033333335))
   (:vel-z (meters -0.006666667) (meters 0.013333334))
   (:scalevel-x (meters 0.006666667))
   (:rotvel-z (degrees -0.3) (degrees 0.6))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 1.28)
   (:accel-y (meters 0.0000033333336))
   (:friction 0.99)
   (:timer (seconds 3))
   (:flags (bit2))
   (:next-time (seconds 0.15) (seconds 0.097))
   (:next-launcher 790)
   (:rotate-y (degrees 90))))

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; MUSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ;;-*-Lisp-*-
(in-package goal)
(bundles "MIS.DGO")
(require "engine/common-obs/nav-enemy.gc")

;; DECOMP BEGINS

(deftype muse-overgrown (nav-enemy)
  ((root               collide-shape-moving :override)
   (current-path-index float)
   (prev-path-index    float)
   (dest-path-index    float)
   (player-path-index  float)
   (max-path-index     float)
   (sprint-distance    float)
   (dest-point         vector :inline)
   (anim               spool-anim)
   (victory-anim       spool-anim)
   (old-target-pos     transformq :inline))
  (:states
   muse-overgrown-caught
   muse-overgrown-idle))

(deftype point-on-path-segment-info (structure)
  ((point               vector :inline)
   (segment             vector 2 :inline)
   (dir                 vector :inline)
   (nearest-point       vector :inline)
   (segment-length      float)
   (distance-to-segment float)
   (parametric-index    float)))

(defun analyze-point-on-path-segment ((arg0 point-on-path-segment-info))
  (vector-! (-> arg0 dir) (-> arg0 segment 1) (the-as vector (-> arg0 segment)))
  (vector-normalize! (-> arg0 dir) 1.0)
  (set! (-> arg0 segment-length) (vector-vector-distance (the-as vector (-> arg0 segment)) (-> arg0 segment 1)))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (vector-! s5-0 (the-as vector (-> arg0 segment)) (-> arg0 point))
    (vector+*! s5-0 s5-0 (-> arg0 dir) (- (vector-dot s5-0 (-> arg0 dir))))
    (vector+! (-> arg0 nearest-point) (-> arg0 point) s5-0)
    (set! (-> arg0 distance-to-segment) (vector-length s5-0))
    (vector-! s5-0 (-> arg0 point) (the-as vector (-> arg0 segment)))
    (set! (-> arg0 parametric-index) (/ (vector-dot (-> arg0 dir) s5-0) (-> arg0 segment-length))))
  (cond
    ((< (-> arg0 parametric-index) 0.0)
     (set! (-> arg0 parametric-index) 0.0)
     (set! (-> arg0 nearest-point quad) (-> arg0 segment 0 quad))
     (set! (-> arg0 distance-to-segment) (vector-vector-distance (-> arg0 nearest-point) (-> arg0 point))))
    ((< 1.0 (-> arg0 parametric-index))
     (set! (-> arg0 parametric-index) 1.0)
     (set! (-> arg0 nearest-point quad) (-> arg0 segment 1 quad))
     (set! (-> arg0 distance-to-segment) (vector-vector-distance (-> arg0 nearest-point) (-> arg0 point))))))

(defbehavior muse-get-path-point muse ((arg0 vector) (arg1 int))
  (eval-path-curve-div! (-> self path) arg0 (the float arg1) 'interp)
  0
  (none))

(defbehavior muse-check-dest-point muse ()
  (let ((gp-0 (new 'stack-no-clear 'point-on-path-segment-info))
        (f26-0 4096000.0)
        (f30-0 0.0)
        (f24-0 4096000.0)
        (f28-0 0.0))
    (let ((s5-0 (+ (-> self path curve num-cverts) -1))
          (s4-0 (target-pos 0)))
      (dotimes (s3-0 s5-0)
        (let ((f22-0 (the float s3-0)))
          (let ((f20-0 (the float (+ s3-0 1))))
            (eval-path-curve-div! (-> self path) (the-as vector (-> gp-0 segment)) f22-0 'interp)
            (eval-path-curve-div! (-> self path) (-> gp-0 segment 1) f20-0 'interp))
          (set! (-> gp-0 point quad) (-> s4-0 quad))
          (analyze-point-on-path-segment gp-0)
          (when (< (-> gp-0 distance-to-segment) f24-0)
            (set! f24-0 (-> gp-0 distance-to-segment))
            (set! f28-0 (+ f22-0 (-> gp-0 parametric-index))))
          (set! (-> gp-0 point quad) (-> self collide-info trans quad))
          (analyze-point-on-path-segment gp-0)
          (when (< (-> gp-0 distance-to-segment) f26-0)
            (set! f26-0 (-> gp-0 distance-to-segment))
            (set! f30-0 (+ f22-0 (-> gp-0 parametric-index)))))
        0))
    (let ((f0-6 (- f30-0 f28-0)))
      (if (< f0-6 (* -0.5 (-> self max-path-index))) (+! f0-6 (-> self max-path-index)))
      (if (< (* 0.5 (-> self max-path-index)) f0-6) (set! f0-6 (- f0-6 (-> self max-path-index))))
      (cond
        ((>= f0-6 0.0)
         (set! (-> self dest-path-index) (the float (the int (+ 2.5 f30-0))))
         (if (>= (-> self dest-path-index) (-> self max-path-index))
           (set! (-> self dest-path-index) (- (-> self dest-path-index) (-> self max-path-index)))))
        (else
         (set! (-> self dest-path-index) (+ -1.5 f30-0))
         (if (< (-> self dest-path-index) 0.0) (+! (-> self dest-path-index) (-> self max-path-index)))
         (set! (-> self dest-path-index) (the float (the int (-> self dest-path-index))))))))
  (eval-path-curve-div! (-> self path) (-> self dest-point) (-> self dest-path-index) 'interp)
  0
  (none))

(defmethod nav-enemy-method-51 ((this muse-overgrown))
  (dotimes (s5-0 5) ;; iterates how many times this is run. increased from 2 to 5 for more particles launched.
    (let ((v1-2 (rand-vu-int-range 3 (+ (-> this node-list length) -1))))
      (launch-particles (-> *part-id-table* 279) (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data v1-2))))) ;;271 is default. 260 is pretty blue. 277 is green eco effect. 279 is sparkly green.
  0
  (none))

(defmethod common-post ((this muse-overgrown))
  (spool-push *art-control* (-> this anim name) 0 this -99.0)
  (nav-enemy-method-51 this)
  ((method-of-type nav-enemy common-post) this)
  (none))

(defskelgroup *muse-sg*
  muse
  muse-lod0-jg
  muse-idle-ja
  ((muse-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 2 0 3)
  :shadow muse-shadow-mg)

(defmethod touch-handler ((this muse-overgrown) (arg0 process) (arg1 event-message-block))
  (go muse-overgrown-caught))

(defmethod attack-handler ((this muse-overgrown) (arg0 process) (arg1 event-message-block))
  (go muse-overgrown-caught))

nav-enemy-default-event-handler

(defstate muse-overgrown-idle (muse-overgrown)
  :event nav-enemy-default-event-handler
  :trans
    (behavior ()
      (seek! (-> self sprint-distance) 161440.0 (* 8192.0 (seconds-per-frame))) ;; value is how long the muse can sprint for
      (if (and *target* (>= 102400.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
        (level-hint-spawn (text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none)))
      (if (and *target* (>= 81920.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
        (go-virtual nav-enemy-chase)))
  :code
    (behavior ()
      (when (ja-group? muse-run-ja)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :num! (loop!))
        (ja-no-eval :group! muse-run-to-idle-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (ja :num! (seek!))))
      (loop
        (ja-no-eval :group! muse-idle-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (spool-push *art-control* (-> self anim name) 0 self -99.0)
          (nav-enemy-method-51 self)
          (suspend)
          (ja :num! (seek!)))))
  :post ja-post)

(defstate nav-enemy-chase (muse-overgrown)
  :virtual #t
  :event nav-enemy-default-event-handler
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :trans
    (behavior ()
      (cond
        ((or (not *target*) (< 202400.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans)))) ;; distance in which the muse can be from you.
         (set! (-> self target-speed) 0.0)
         (if (= (-> self momentum-speed) 0.0) (go muse-overgrown-idle)))
        ((or (not *target*)
             (< (-> self sprint-distance) (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
         (set! (-> self target-speed) 40960.0))
        (else (set! (-> self target-speed) 61440.0))) ;; sprint speed of muse
      (seek! (-> self sprint-distance) 0.0 (* 4096.0 (seconds-per-frame)))
      (muse-check-dest-point))
  :code
    (behavior ()
      (cond
        ((ja-group? muse-idle-ja)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :num! (loop!))
         (ja-no-eval :group! muse-idle-to-run-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (ja-blend-eval)
           (suspend)
           (ja :num! (seek!))))
        (else (ja-channel-push! 1 (seconds 0.1))))
      (ja :group! muse-run-ja :num! min)
      (loop
        (suspend)
        (ja :num! (loop! (* 0.000016276043 (-> self momentum-speed))))))
  :post
    (behavior ()
      (set! (-> self nav destination-pos quad) (-> self dest-point quad))
      (nav-control-method-19 (-> self nav)
                             (-> self nav target-pos)
                             (-> self collide-info)
                             (-> self nav destination-pos)
                             546133.3)
      (if (logtest? (nav-control-flags navcf21) (-> self nav flags)) (logclear! (-> self nav flags) (nav-control-flags navcf10)))
      (nav-enemy-travel-post)))

(defstate nav-enemy-jump (muse-overgrown)
  :virtual #t
  :event nav-enemy-default-event-handler
  :enter
    (behavior ()
      ((-> (method-of-type nav-enemy nav-enemy-jump) enter))
      (logclear! (-> self nav-enemy-flags) (nav-enemy-flags standing-jump)))
  :code
    (-> (method-of-type nav-enemy nav-enemy-jump)
        code))

(defstate nav-enemy-jump-land (muse-overgrown)
  :virtual #t
  :event nav-enemy-default-event-handler
  :code
    (behavior ()
      (ja-no-eval :num! (seek!))
      (ja-channel-push! 1 (seconds 0.075))
      (ja-no-eval :group! muse-run-ja :num! (seek! max 0.8) :frame-num (ja-aframe 6.0 0))
      (until (ja-done? 0)
        (ja-blend-eval)
        (suspend)
        (ja :num! (seek! max 0.8)))
      (go-virtual nav-enemy-chase)))

(defstate muse-overgrown-caught (muse-overgrown)
  :event #f
  :trans
    (behavior ()
      (spool-push *art-control* (-> self anim name) 0 self -1.0))
  :code
    (behavior ()
      (sound-play "money-pickup")
      (close-specific-task! (game-task overgrown-muse) (task-status need-reminder))
      (process-entity-status! self (entity-perm-status dead) #t)
      (suspend)
      (when (send-event *target* 'clone-anim self)
        (set-blackout-frames (seconds 10))
        (let ((gp-1 (res-lump-struct (-> self entity) 'movie-pos vector)))
          (cond
            (gp-1 (move-to-point! (-> self collide-info) gp-1) (set-yaw-angle-clear-roll-pitch! (-> self collide-info) (-> gp-1 w)))
            (else
             (move-to-point! (-> self collide-info) (-> *target* control trans))
             (quaternion-copy! (-> self collide-info quat) (-> *target* control quat))
             (move-to-ground (-> self collide-info) 40960.0 40960.0 #f (collide-kind background)))))
        (send-event *target* 'trans 'save (-> self old-target-pos))
        (send-event (ppointer->process (-> *target* sidekick)) 'matrix 'play-anim)
        (send-event *target* 'blend-shape #t)
        (if (= *kernel-boot-message* 'play)
        (format 0 "Inside non-play mode branch one~%")
          (set! (-> self trans-hook)
                (lambda :behavior muse ()
                  (spool-push *art-control* (-> self victory-anim name) 0 self -1.0)
                  (none))))
        (add-setting! 'music-volume 'rel (-> *setting-control* current music-volume-movie) 0)
        (add-setting! 'sfx-volume 'rel (-> *setting-control* current sfx-volume-movie) 0)
        (add-setting! 'ambient-volume 'rel (-> *setting-control* current ambient-volume-movie) 0)
        (logclear! (-> self mask) (process-mask enemy))
        (process-spawn othercam self 3 #f #t :to self)
        (auto-save-command 'auto-save 0 0 *default-pool*)
        (ja-play-spooled-anim (-> self anim)
                              (the-as art-joint-anim muse-idle-ja)
                              (the-as art-joint-anim muse-idle-ja)
                              (the-as (function process-drawable symbol) false-func))
        (remove-setting! 'music-volume)
        (remove-setting! 'sfx-volume)
        (remove-setting! 'ambient-volume)
        (send-event *target* 'blend-shape #f)
        (cond
          ((= *kernel-boot-message* 'play)
          (format 0 "Inside nonplay mode branch 2.~%")
           (set-blackout-frames 0)
           (ja-channel-set! 0)
           (ja-post)
           (clear-collide-with-as (-> self collide-info))
           (send-event *target* 'trans 'reset)
           (let ((gp-4 (ppointer->handle (birth-pickup-at-point (target-pos 0)
                                                                (pickup-type fuel-cell)
                                                                (the float (-> self entity extra perm task))
                                                                #f
                                                                self
                                                                (the-as fact-info #f)))))
             (send-event (handle->process (the-as handle gp-4)) 'pickup)
             (while (handle->process (the-as handle gp-4))
               (suspend))))
          (else
            (format 0 "Inside play mode branch.~%")
           (send-event *target* 'trans 'restore (-> self old-target-pos))
           (set-blackout-frames 0)
           (set-blackout-frames (seconds 0.1))))))
  :post
    (behavior ()
      (nav-enemy-method-51 self)
      (level-hint-surpress!)
      (kill-current-level-hint '() '() 'exit)
      (ja-post)))

(define *muse-nav-enemy-info*
  (new 'static
       'nav-enemy-info
       :idle-anim 3
       :walk-anim 4
       :turn-anim -1
       :notice-anim 3
       :run-anim 4
       :jump-anim 7
       :jump-land-anim 8
       :victory-anim 3
       :taunt-anim 3
       :die-anim 3
       :neck-joint 6
       :player-look-at-joint 5
       :run-travel-speed (meters 10)
       :run-rotate-speed (degrees 999.99994)
       :run-acceleration (meters 5)
       :run-turn-time (seconds 0.15)
       :walk-travel-speed (meters 10)
       :walk-rotate-speed (degrees 999.99994)
       :walk-acceleration (meters 1)
       :walk-turn-time (seconds 0.15)
       :attack-shove-back (meters 3)
       :attack-shove-up (meters 2)
       :shadow-size (meters 2)
       :notice-nav-radius (meters 1)
       :nav-nearest-y-threshold (meters 10)
       :notice-distance (meters 30)
       :stop-chase-distance (meters 40)
       :frustration-distance (meters 8)
       :frustration-time (seconds 4)
       :die-anim-hold-frame 10000000000.0
       :jump-anim-start-frame 6.5
       :jump-land-anim-end-frame 10000000000.0
       :jump-height-min (meters 1)
       :jump-height-factor 0.5
       :jump-start-anim-speed 1.0
       :shadow-max-y (meters 1)
       :shadow-min-y (meters -1)
       :shadow-locus-dist (meters 150)
       :use-align #f
       :draw-shadow #t
       :move-to-ground #t
       :hover-if-no-ground #f
       :use-momentum #f
       :use-flee #f
       :use-proximity-notice #f
       :use-jump-blocked #f
       :use-jump-patrol #f
       :gnd-collide-with (collide-kind background)
       :debug-draw-neck #f
       :debug-draw-jump #f))

(defmethod init-from-entity! ((this muse-overgrown) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 2457.6 0.0 2457.6)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this collide-info) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *muse-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-defaults! this *muse-nav-enemy-info*)
  (set! (-> this max-path-index) (the float (+ (-> this path curve num-cverts) -1)))
  (set! (-> this current-path-index) 7.0)
  (set! (-> this prev-path-index) 7.0)
  (set! (-> this dest-path-index) 7.0)
  (set! (-> this player-path-index) 0.0)
  (eval-path-curve-div! (-> this path) (-> this dest-point) (-> this current-path-index) 'interp)
  (set! (-> this collide-info trans quad) (-> this dest-point quad))
  (set! (-> this nav nearest-y-threshold) 20480.0)
  (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
  (set! (-> this neck up) (the-as uint 0))
  (set! (-> this neck nose) (the-as uint 1))
  (set! (-> this neck ear) (the-as uint 2))
  (set! (-> this neck max-dist) 102400.0)
  (set! (-> this neck ignore-angle) 16384.0)
  (set! (-> this anim)
        (new 'static 'spool-anim :name "muse-victory" :index 9 :parts 2 :command-list '((1 blackout 0) (219 blackout 60))))
  (set! (-> this victory-anim) (fuel-cell-pick-anim this))
  (go muse-overgrown-idle)
  (none))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; WARPGATE ANIM ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defpartgroup group-overgrown-warpgate
  :id 150
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 767 :fade-after (meters 60) :falloff-to (meters 60))
    (sp-item 768 :fade-after (meters 60) :falloff-to (meters 100) :binding 765)
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 769 :fade-after (meters 60) :falloff-to (meters 100) :binding 766)
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 770 :fade-after (meters 100) :flags (is-3d))
    )
  )

(defpart 770
  :init-specs ((:texture (new 'static 'texture-id :index #x3 :page #x2))
    (:num 0.5)
    (:x (meters -11.6666667))
    (:scale-x (meters 5))
    (:rot-x (degrees 90))
    (:rot-z (degrees 15))
    (:scale-y :copy scale-x)
    (:r 0.0 0.0)
    (:g 0.0 64.0)
    (:b 0.0 0.0)
    (:a 0.0 64.0)
    (:timer (seconds 0.035))
    (:flags (bit3 bit14))
    )
  )

(defpart 769
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 0.25)
    (:x (meters -2))
    (:scale-x (meters 0.25))
    (:scale-y :copy scale-x)
    (:g 128.0)
    (:a 0.0)
    (:vel-x (meters 0.0033333334))
    (:timer (seconds 2))
    (:flags (bit3 bit14))
    (:rotate-y (degrees -105))
    )
  )

(defpart 766
  :init-specs ((:texture (new 'static 'texture-id :index #x4 :page #x2))
    (:num 1.0)
    (:x (meters -11.0666667)) ;; THE ROTATION FIELD.
    (:y (meters 4))
    (:z (meters 5.4) (meters 1))
    (:scale-x (meters 0.2) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 0.0 0.0)
    (:g 0.0 64.0)
    (:b 0.0 0.0)
    (:a 0.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters 0))
    (:vel-z (meters 0))
    (:fade-a 0.16)
    (:accel-x (meters 0.0002962963))
    (:accel-z (meters -0.00018333334))
    (:timer (seconds 2))
    (:flags (bit2 bit3 bit7 bit14))
    )
  )

(defpart 767
  :init-specs ((:num 3.0 3.0)
    (:x (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 3481.6)
    (:b 3481.6)
    (:vel-y (meters -0.026666667) (meters -0.02))
    (:fade-b 2.968116)
    (:timer (seconds 0.23))
    (:flags (aux-list))
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-radius (meters 4) (meters 3))
    (:rotate-y (degrees -105))
    )
  )

(defpart 768
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0)
    (:scale-x (meters 0.25))
    (:scale-y :copy scale-x)
    (:g 128.0)
    (:a 0.0)
    (:accel-x (meters 0.000016666667))
    (:timer (seconds 2.3))
    (:flags (bit3 bit14))
    (:rotate-y (degrees -105))
    )
  )

(defpart 765
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:x (meters -11.6666667)) ;; THIS IS THE ROTATION FIELD
    (:y (meters 4))
    (:z (meters 2.4))
    (:scale-x (meters 1.1) (meters 0.6))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0 0.0)
    (:g 0.0 64.0)
    (:b 5.0 32.0)
    (:a 8.0 32.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters -0.0044444446))
    (:vel-z (meters -0.0034999999))
    (:rotvel-z (degrees 0) (degrees 1.2))
    (:fade-a 0.21333334)
    (:accel-x (meters 0.0010370371))
    (:timer (seconds 2.3))
    (:flags (bit2 bit3 bit7 bit14))
    )
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; IRIS DOOR ;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype overgrown-iris-door (eco-door) ())

(defstate door-closed (overgrown-iris-door)
  :virtual #t
  :event eco-door-event-handler
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (suspend)
    (update-transforms! (-> self root))
    (ja-post)
    (loop
      (when (and *target*
                 (>= (-> self open-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                 )
        (eco-door-method-26 self)
        (if (and (not (-> self locked))
                 (or (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status complete)))
                     (and (task-complete? *game-info* (game-task overgrown-button1)) (task-complete? *game-info* (game-task overgrown-button2)) (task-complete? *game-info* (game-task overgrown-button3)))
                     (and (-> self one-way) (< (vector4-dot (-> self out-dir) (target-pos 0)) -8192.0))
                     )
                 )
            (go-virtual door-opening)
            )
        (level-hint-spawn (text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none))
        )
      (suspend)
      )
    )
  )

(defskelgroup *jng-iris-door-sg*
  jng-iris-door
  jng-iris-door-lod0-jg
  jng-iris-door-idle-ja
  ((jng-iris-door-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 8))

(defmethod eco-door-method-24 ((this overgrown-iris-door))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-others))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set-root-prim! s5-0 s4-0))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))

  0
  (none))

(defmethod eco-door-method-25 ((this overgrown-iris-door))
  (initialize-skeleton this *jng-iris-door-sg* '())
  (set! (-> this open-distance) 32768.0)
  (set! (-> this close-distance) 49152.0)
  (update-transforms! (-> this root))
  0
  (none))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GENERIC BUTTON;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (deftype overgrown-switch (basebutton)
  ((fcell-handle handle)))

(defmethod init-from-entity! ((this overgrown-switch) (arg0 entity-actor))
  (reset! this)
  (set! (-> this spawned-by-other?) #f)
  (set! (-> this button-id) -1)
  (set! (-> this fcell-handle) (the-as handle #f))
  (let ((v1-4 (res-lump-value (-> this entity) 'extra-id uint128 :default (the-as uint128 -1))))
    (if (>= (the-as int v1-4) 0) (set! (-> this button-id) (the-as int v1-4))))
  (when (or (res-lump-struct arg0 'next-actor structure) (res-lump-struct arg0 'prev-actor structure))
    (set! (-> this link) (new 'process 'actor-link-info this))
    (if (< (-> this button-id) 0) (set! (-> this button-id) (actor-count-before (-> this link)))))
  (basebutton-method-27 this)
  (process-drawable-from-entity! this arg0)

  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this timeout) (res-lump-float arg0 'timeout))
  (if (not (-> this spawned-by-other?)) (nav-mesh-connect this (-> this root) (the-as nav-control #f)))
  (arm-trigger-event! this)
  (basebutton-method-26 this)
  (go (method-of-object this basebutton-startup))
  (none))

(defstate basebutton-up-idle (overgrown-switch)
  :virtual #t
  :event
  (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (case (-> block param 1)
         (('flop)
          (basebutton-method-29 self (-> self event-going-down) (-> self notify-actor))
          (sound-play "silo-button")
          (go-virtual basebutton-going-down)
          (close-specific-task! (-> self entity extra perm task) (task-status need-resolution))
          (entity-task-complete-on (-> self entity))



          )
         )
       )
      (('trigger)
       (sound-play "silo-button")
       (go-virtual basebutton-going-down)
       )
      (('move-to)
       (move-to-vec-or-quat! self (the-as vector (-> block param 0)) (the-as quaternion (-> block param 1)))
       )
      )
    )
  :enter
    (behavior ()
      (press! self #f))
  :trans
    (behavior ()
      (if (-> self move-to?)
        (rider-trans) ;; Probably need to clean up all this rider code later, it is not needed here.
        ))
  :code anim-loop
  :post
    (behavior ()
      (when (-> self move-to?)
        (set! (-> self move-to?) #f)
        (set! (-> self root trans quad) (-> self move-to-pos quad))
        (quaternion-copy! (-> self root quat) (-> self move-to-quat))
        (rider-post))))